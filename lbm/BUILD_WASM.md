# Building the WebAssembly LBM Solver

This guide explains how to compile the C++ LBM solver to WebAssembly for use in the browser.

## Prerequisites

### 1. Install Emscripten

Emscripten is the toolchain that compiles C++ to WebAssembly.

**Windows:**
```bash
# Download and install Emscripten
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
emsdk install latest
emsdk activate latest
```

**macOS/Linux:**
```bash
# Download and install Emscripten
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
```

After installation, activate the Emscripten environment:

**Windows:**
```bash
emsdk_env.bat
```

**macOS/Linux:**
```bash
source ./emsdk_env.sh
```

### 2. Verify Installation

```bash
emcc --version
```

You should see output showing the Emscripten compiler version.

## Building the WASM Module

Navigate to your portfolio directory and run:

```bash
emcc lbm-solver.cpp \
  -o lbm-solver-wasm.js \
  -std=c++17 \
  -O3 \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s MODULARIZE=1 \
  -s EXPORT_NAME="createLBMModule" \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  --bind \
  -s INITIAL_MEMORY=67108864 \
  -s MAXIMUM_MEMORY=268435456
```

### Build Flags Explained

- `-o lbm-solver-wasm.js` - Output filename (generates both .js and .wasm files)
- `-std=c++17` - Use C++17 standard
- `-O3` - Maximum optimization level
- `-s WASM=1` - Generate WebAssembly (not asm.js)
- `-s ALLOW_MEMORY_GROWTH=1` - Allow dynamic memory allocation
- `-s MODULARIZE=1` - Wrap in a factory function
- `-s EXPORT_NAME="createLBMModule"` - Name of the factory function
- `--bind` - Enable Emscripten bindings for C++/JavaScript interop
- `-s INITIAL_MEMORY=67108864` - Start with 64MB memory (enough for 600×300 grid)
- `-s MAXIMUM_MEMORY=268435456` - Allow up to 256MB for larger grids

### Output Files

The build will generate two files:
- `lbm-solver-wasm.js` - JavaScript loader and glue code
- `lbm-solver-wasm.wasm` - The actual WebAssembly binary

## Development vs Production Builds

### Development Build (with debugging)

```bash
emcc lbm-solver.cpp \
  -o lbm-solver-wasm.js \
  -std=c++17 \
  -O0 \
  -g \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s MODULARIZE=1 \
  -s EXPORT_NAME="createLBMModule" \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  --bind \
  -s ASSERTIONS=1 \
  -s SAFE_HEAP=1
```

This includes debugging symbols and runtime checks.

### Production Build (optimized)

```bash
emcc lbm-solver.cpp \
  -o lbm-solver-wasm.js \
  -std=c++17 \
  -O3 \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s MODULARIZE=1 \
  -s EXPORT_NAME="createLBMModule" \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  --bind \
  -flto
```

The `-flto` flag enables Link Time Optimization for even better performance.

## Using the WASM Module

### 1. Update index.html

Uncomment the WASM loader lines in `index.html`:

```html
<!-- LBM Solver: Load WASM version if available, otherwise use JavaScript -->
<!-- WASM loader (generated by Emscripten) -->
<script src="lbm-solver-wasm.js"></script>
<script src="lbm-solver-wasm-wrapper.js"></script>

<!-- JavaScript fallback version (comment out when using WASM) -->
<!-- <script src="lbm-solver.js"></script> -->

<script src="script.js"></script>
```

### 2. Initialize the Module

The WASM module needs to be initialized before use. The JavaScript wrapper (`lbm-solver-wasm.js`) handles this automatically.

When you load the page, check the console. You should see:
```
Using WebAssembly LBM solver
WASM LBM Solver initialized
```

## Performance Comparison

Expected performance improvements with WASM:

| Resolution | JavaScript | WASM (C++) | Speedup |
|------------|------------|------------|---------|
| 600×300    | ~20-30 FPS | ~100-150 FPS | 5-7x |
| 1200×600   | ~5-8 FPS   | ~35-50 FPS | 6-8x |

## Troubleshooting

### "Module is not defined"

Make sure the WASM loader script is loaded before the wrapper:
```html
<script src="lbm-solver-wasm.js"></script>  <!-- Must be first -->
<script src="lbm-solver-wasm-wrapper.js"></script>
```

### Memory errors

If you see out-of-memory errors, increase the memory limits:
```bash
-s INITIAL_MEMORY=134217728    # 128MB
-s MAXIMUM_MEMORY=536870912    # 512MB
```

### CORS errors when testing locally

WASM files must be served over HTTP (not `file://`). Use a local server:

```bash
# Python 3
python -m http.server 8000

# Node.js (install http-server globally first)
npx http-server

# VS Code Live Server extension (recommended)
Right-click index.html → "Open with Live Server"
```

Then navigate to `http://localhost:8000`

### Slow build times

The first build can take 30-60 seconds. Subsequent builds are faster. Use `-O2` instead of `-O3` for faster compilation during development:

```bash
emcc lbm-solver.cpp -o lbm-solver-wasm.js -std=c++17 -O2 --bind
```

## Advanced: Optimizing for Higher Resolutions

To support higher resolutions (e.g., 1200×600 or 1920×1080):

```bash
emcc lbm-solver.cpp \
  -o lbm-solver-wasm.js \
  -std=c++17 \
  -O3 \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s MODULARIZE=1 \
  -s EXPORT_NAME="createLBMModule" \
  --bind \
  -s INITIAL_MEMORY=268435456 \
  -s MAXIMUM_MEMORY=1073741824 \
  -msimd128 \
  -msse2
```

Additional flags:
- `-msimd128` - Enable SIMD instructions for vectorization
- `-msse2` - Use SSE2 instructions (x86 only)

## Cleaning Build Artifacts

To clean up generated files:

**Windows:**
```bash
del lbm-solver-wasm.js lbm-solver-wasm.wasm
```

**macOS/Linux:**
```bash
rm lbm-solver-wasm.js lbm-solver-wasm.wasm
```

## Next Steps

After building successfully:

1. Test the WASM version in your browser
2. Compare performance with the JavaScript version
3. Experiment with higher resolutions
4. Try more complex geometries
5. Add additional features (time-dependent flows, multiple objects, etc.)

## Resources

- [Emscripten Documentation](https://emscripten.org/docs/getting_started/index.html)
- [WebAssembly MDN](https://developer.mozilla.org/en-US/docs/WebAssembly)
- [Emscripten Settings](https://emsettings.surma.technology/) - Interactive settings reference
